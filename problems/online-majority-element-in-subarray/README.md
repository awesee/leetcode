<!--|This file generated by command(leetcode description); DO NOT EDIT.    |-->
<!--+----------------------------------------------------------------------+-->
<!--|@author    openset <openset.wang@gmail.com>                           |-->
<!--|@link      https://github.com/openset                                 |-->
<!--|@home      https://github.com/openset/leetcode                        |-->
<!--+----------------------------------------------------------------------+-->

[< Previous](../swap-for-longest-repeated-character-substring "Swap For Longest Repeated Character Substring")
　　　　　　　　　　　　　　　　
[Next >](../market-analysis-i "Market Analysis I")

## [1157. Online Majority Element In Subarray (Hard)](https://leetcode.com/problems/online-majority-element-in-subarray "子数组中占绝大多数的元素")

<p>Implementing the class <code>MajorityChecker</code>, which has the following API:</p>

<ul>
	<li><code>MajorityChecker(int[] arr)</code> constructs an instance of MajorityChecker with the given array <code>arr</code>;</li>
	<li><code>int query(int left, int right, int threshold)</code>&nbsp;has arguments&nbsp;such that:
	<ul>
		<li><code>0 &lt;= left&nbsp;&lt;= right&nbsp;&lt; arr.length</code> representing a subarray of <code>arr</code>;</li>
		<li><code>2 * threshold &gt; right - left + 1</code>, ie. the threshold is always a strict majority of the length of&nbsp;the subarray</li>
	</ul>
	</li>
</ul>

<p>Each&nbsp;<code>query(...)</code> returns the element in <code>arr[left], arr[left+1], ..., arr[right]</code> that occurs at least <code>threshold</code> times, or <code>-1</code> if no such element exists.</p>

<p>&nbsp;</p>

<p><strong>Example:</strong></p>

<pre>
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // returns 1
majorityChecker.query(0,3,3); // returns -1
majorityChecker.query(2,3,2); // returns 2
</pre>

<p>&nbsp;</p>
<p><strong>Constraints:</strong></p>

<ul>
	<li><code>1 &lt;= arr.length &lt;=&nbsp;20000</code></li>
	<li><code>1 &lt;= arr[i]&nbsp;&lt;=&nbsp;20000</code></li>
	<li>For each query, <code>0 &lt;= left &lt;= right &lt; len(arr)</code></li>
	<li>For each query, <code>2 * threshold &gt; right - left + 1</code></li>
	<li>The number of queries is at most <code>10000</code></li>
</ul>

### Related Topics
  [[Segment Tree](../../tag/segment-tree/README.md)]
  [[Array](../../tag/array/README.md)]
  [[Binary Search](../../tag/binary-search/README.md)]

### Hints
<details>
<summary>Hint 1</summary>
What's special about a majority element ?
</details>

<details>
<summary>Hint 2</summary>
A majority element appears more than half the length of the array number of times.
</details>

<details>
<summary>Hint 3</summary>
If we tried a random index of the array, what's the probability that this index has a majority element ?
</details>

<details>
<summary>Hint 4</summary>
It's more than 50% if that array has a majority element.
</details>

<details>
<summary>Hint 5</summary>
Try a random index for a proper number of times so that the probability of not finding the answer tends to zero.
</details>
